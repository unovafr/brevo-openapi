=begin
#Brevo API

#Brevo provide a RESTFul API that can be used with any languages. With this API, you will be able to :   - Manage your campaigns and get the statistics   - Manage your contacts   - Send transactional Emails and SMS   - and much more...  You can download our wrappers at https://github.com/orgs/brevo  **Possible responses**   | Code | Message |   | :-------------: | ------------- |   | 200  | OK. Successful Request  |   | 201  | OK. Successful Creation |   | 202  | OK. Request accepted |   | 204  | OK. Successful Update/Deletion  |   | 400  | Error. Bad Request  |   | 401  | Error. Authentication Needed  |   | 402  | Error. Not enough credit, plan upgrade needed  |   | 403  | Error. Permission denied  |   | 404  | Error. Object does not exist |   | 405  | Error. Method not allowed  |   | 406  | Error. Not Acceptable  | 

The version of the OpenAPI document: 3.0.0
Contact: contact@brevo.com
Generated by: https://openapi-generator.tech
Generator version: 7.5.0

=end

require 'cgi'

module Brevo
  class EcommerceApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Create orders in batch
    # Create multiple orders at one time instead of one order at a time
    # @param order_batch [OrderBatch] 
    # @param [Hash] opts the optional parameters
    # @return [CreatedBatchId]
    def create_batch_order(order_batch, opts = {})
      data, _status_code, _headers = create_batch_order_with_http_info(order_batch, opts)
      data
    end

    # Create orders in batch
    # Create multiple orders at one time instead of one order at a time
    # @param order_batch [OrderBatch] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(CreatedBatchId, Integer, Hash)>] CreatedBatchId data, response status code and response headers
    def create_batch_order_with_http_info(order_batch, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: EcommerceApi.create_batch_order ...'
      end
      # verify the required parameter 'order_batch' is set
      if @api_client.config.client_side_validation && order_batch.nil?
        fail ArgumentError, "Missing the required parameter 'order_batch' when calling EcommerceApi.create_batch_order"
      end
      # resource path
      local_var_path = '/orders/status/batch'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(order_batch)

      # return_type
      return_type = opts[:debug_return_type] || 'CreatedBatchId'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key']

      new_options = opts.merge(
        :operation => :"EcommerceApi.create_batch_order",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: EcommerceApi#create_batch_order\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Managing the status of the order
    # Manages the transactional status of the order
    # @param order [Order] 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def create_order(order, opts = {})
      create_order_with_http_info(order, opts)
      nil
    end

    # Managing the status of the order
    # Manages the transactional status of the order
    # @param order [Order] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def create_order_with_http_info(order, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: EcommerceApi.create_order ...'
      end
      # verify the required parameter 'order' is set
      if @api_client.config.client_side_validation && order.nil?
        fail ArgumentError, "Missing the required parameter 'order' when calling EcommerceApi.create_order"
      end
      # resource path
      local_var_path = '/orders/status'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(order)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key']

      new_options = opts.merge(
        :operation => :"EcommerceApi.create_order",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: EcommerceApi#create_order\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create categories in batch
    # @param create_update_batch_category [CreateUpdateBatchCategory] Values to create a batch of categories
    # @param [Hash] opts the optional parameters
    # @return [CreateUpdateBatchCategoryModel]
    def create_update_batch_category(create_update_batch_category, opts = {})
      data, _status_code, _headers = create_update_batch_category_with_http_info(create_update_batch_category, opts)
      data
    end

    # Create categories in batch
    # @param create_update_batch_category [CreateUpdateBatchCategory] Values to create a batch of categories
    # @param [Hash] opts the optional parameters
    # @return [Array<(CreateUpdateBatchCategoryModel, Integer, Hash)>] CreateUpdateBatchCategoryModel data, response status code and response headers
    def create_update_batch_category_with_http_info(create_update_batch_category, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: EcommerceApi.create_update_batch_category ...'
      end
      # verify the required parameter 'create_update_batch_category' is set
      if @api_client.config.client_side_validation && create_update_batch_category.nil?
        fail ArgumentError, "Missing the required parameter 'create_update_batch_category' when calling EcommerceApi.create_update_batch_category"
      end
      # resource path
      local_var_path = '/categories/batch'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(create_update_batch_category)

      # return_type
      return_type = opts[:debug_return_type] || 'CreateUpdateBatchCategoryModel'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key']

      new_options = opts.merge(
        :operation => :"EcommerceApi.create_update_batch_category",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: EcommerceApi#create_update_batch_category\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create products in batch
    # @param create_update_batch_products [CreateUpdateBatchProducts] Values to create a batch of products
    # @param [Hash] opts the optional parameters
    # @return [CreateUpdateBatchProductsModel]
    def create_update_batch_products(create_update_batch_products, opts = {})
      data, _status_code, _headers = create_update_batch_products_with_http_info(create_update_batch_products, opts)
      data
    end

    # Create products in batch
    # @param create_update_batch_products [CreateUpdateBatchProducts] Values to create a batch of products
    # @param [Hash] opts the optional parameters
    # @return [Array<(CreateUpdateBatchProductsModel, Integer, Hash)>] CreateUpdateBatchProductsModel data, response status code and response headers
    def create_update_batch_products_with_http_info(create_update_batch_products, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: EcommerceApi.create_update_batch_products ...'
      end
      # verify the required parameter 'create_update_batch_products' is set
      if @api_client.config.client_side_validation && create_update_batch_products.nil?
        fail ArgumentError, "Missing the required parameter 'create_update_batch_products' when calling EcommerceApi.create_update_batch_products"
      end
      # resource path
      local_var_path = '/products/batch'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(create_update_batch_products)

      # return_type
      return_type = opts[:debug_return_type] || 'CreateUpdateBatchProductsModel'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key']

      new_options = opts.merge(
        :operation => :"EcommerceApi.create_update_batch_products",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: EcommerceApi#create_update_batch_products\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create/Update a category
    # @param create_update_category [CreateUpdateCategory] Values to create/update a category
    # @param [Hash] opts the optional parameters
    # @return [CreateCategoryModel]
    def create_update_category(create_update_category, opts = {})
      data, _status_code, _headers = create_update_category_with_http_info(create_update_category, opts)
      data
    end

    # Create/Update a category
    # @param create_update_category [CreateUpdateCategory] Values to create/update a category
    # @param [Hash] opts the optional parameters
    # @return [Array<(CreateCategoryModel, Integer, Hash)>] CreateCategoryModel data, response status code and response headers
    def create_update_category_with_http_info(create_update_category, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: EcommerceApi.create_update_category ...'
      end
      # verify the required parameter 'create_update_category' is set
      if @api_client.config.client_side_validation && create_update_category.nil?
        fail ArgumentError, "Missing the required parameter 'create_update_category' when calling EcommerceApi.create_update_category"
      end
      # resource path
      local_var_path = '/categories'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(create_update_category)

      # return_type
      return_type = opts[:debug_return_type] || 'CreateCategoryModel'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key']

      new_options = opts.merge(
        :operation => :"EcommerceApi.create_update_category",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: EcommerceApi#create_update_category\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create/Update a product
    # @param create_update_product [CreateUpdateProduct] Values to create/update a product
    # @param [Hash] opts the optional parameters
    # @return [CreateProductModel]
    def create_update_product(create_update_product, opts = {})
      data, _status_code, _headers = create_update_product_with_http_info(create_update_product, opts)
      data
    end

    # Create/Update a product
    # @param create_update_product [CreateUpdateProduct] Values to create/update a product
    # @param [Hash] opts the optional parameters
    # @return [Array<(CreateProductModel, Integer, Hash)>] CreateProductModel data, response status code and response headers
    def create_update_product_with_http_info(create_update_product, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: EcommerceApi.create_update_product ...'
      end
      # verify the required parameter 'create_update_product' is set
      if @api_client.config.client_side_validation && create_update_product.nil?
        fail ArgumentError, "Missing the required parameter 'create_update_product' when calling EcommerceApi.create_update_product"
      end
      # resource path
      local_var_path = '/products'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(create_update_product)

      # return_type
      return_type = opts[:debug_return_type] || 'CreateProductModel'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key']

      new_options = opts.merge(
        :operation => :"EcommerceApi.create_update_product",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: EcommerceApi#create_update_product\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Activate the eCommerce app
    # Getting access to Brevo eCommerce.
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def ecommerce_activate_post(opts = {})
      ecommerce_activate_post_with_http_info(opts)
      nil
    end

    # Activate the eCommerce app
    # Getting access to Brevo eCommerce.
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def ecommerce_activate_post_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: EcommerceApi.ecommerce_activate_post ...'
      end
      # resource path
      local_var_path = '/ecommerce/activate'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key']

      new_options = opts.merge(
        :operation => :"EcommerceApi.ecommerce_activate_post",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: EcommerceApi#ecommerce_activate_post\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get detailed attribution metrics for a single Brevo campaign
    # @param conversion_source [String] The Brevo campaign type for which data will be retrieved
    # @param conversion_source_id [Float] The Brevo campaign id for which data will be retrieved
    # @param [Hash] opts the optional parameters
    # @return [EcommerceAttributionMetricsConversionSourceConversionSourceIdGet200Response]
    def ecommerce_attribution_metrics_conversion_source_conversion_source_id_get(conversion_source, conversion_source_id, opts = {})
      data, _status_code, _headers = ecommerce_attribution_metrics_conversion_source_conversion_source_id_get_with_http_info(conversion_source, conversion_source_id, opts)
      data
    end

    # Get detailed attribution metrics for a single Brevo campaign
    # @param conversion_source [String] The Brevo campaign type for which data will be retrieved
    # @param conversion_source_id [Float] The Brevo campaign id for which data will be retrieved
    # @param [Hash] opts the optional parameters
    # @return [Array<(EcommerceAttributionMetricsConversionSourceConversionSourceIdGet200Response, Integer, Hash)>] EcommerceAttributionMetricsConversionSourceConversionSourceIdGet200Response data, response status code and response headers
    def ecommerce_attribution_metrics_conversion_source_conversion_source_id_get_with_http_info(conversion_source, conversion_source_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: EcommerceApi.ecommerce_attribution_metrics_conversion_source_conversion_source_id_get ...'
      end
      # verify the required parameter 'conversion_source' is set
      if @api_client.config.client_side_validation && conversion_source.nil?
        fail ArgumentError, "Missing the required parameter 'conversion_source' when calling EcommerceApi.ecommerce_attribution_metrics_conversion_source_conversion_source_id_get"
      end
      # verify enum value
      allowable_values = ["email_campaign"]
      if @api_client.config.client_side_validation && !allowable_values.include?(conversion_source)
        fail ArgumentError, "invalid value for \"conversion_source\", must be one of #{allowable_values}"
      end
      # verify the required parameter 'conversion_source_id' is set
      if @api_client.config.client_side_validation && conversion_source_id.nil?
        fail ArgumentError, "Missing the required parameter 'conversion_source_id' when calling EcommerceApi.ecommerce_attribution_metrics_conversion_source_conversion_source_id_get"
      end
      # resource path
      local_var_path = '/ecommerce/attribution/metrics/{conversionSource}/{conversionSourceId}'.sub('{' + 'conversionSource' + '}', CGI.escape(conversion_source.to_s)).sub('{' + 'conversionSourceId' + '}', CGI.escape(conversion_source_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'EcommerceAttributionMetricsConversionSourceConversionSourceIdGet200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key']

      new_options = opts.merge(
        :operation => :"EcommerceApi.ecommerce_attribution_metrics_conversion_source_conversion_source_id_get",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: EcommerceApi#ecommerce_attribution_metrics_conversion_source_conversion_source_id_get\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get attribution metrics for one or more Brevo campaigns
    # @param [Hash] opts the optional parameters
    # @option opts [Time] :period_from When getting metrics for a specific period, define the starting datetime in RFC3339 format
    # @option opts [Time] :period_to When getting metrics for a specific period, define the end datetime in RFC3339 format
    # @option opts [Array<Float>] :email_campaign_id The email campaign id(s) to get metrics for
    # @return [EcommerceAttributionMetricsGet200Response]
    def ecommerce_attribution_metrics_get(opts = {})
      data, _status_code, _headers = ecommerce_attribution_metrics_get_with_http_info(opts)
      data
    end

    # Get attribution metrics for one or more Brevo campaigns
    # @param [Hash] opts the optional parameters
    # @option opts [Time] :period_from When getting metrics for a specific period, define the starting datetime in RFC3339 format
    # @option opts [Time] :period_to When getting metrics for a specific period, define the end datetime in RFC3339 format
    # @option opts [Array<Float>] :email_campaign_id The email campaign id(s) to get metrics for
    # @return [Array<(EcommerceAttributionMetricsGet200Response, Integer, Hash)>] EcommerceAttributionMetricsGet200Response data, response status code and response headers
    def ecommerce_attribution_metrics_get_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: EcommerceApi.ecommerce_attribution_metrics_get ...'
      end
      # resource path
      local_var_path = '/ecommerce/attribution/metrics'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'periodFrom'] = opts[:'period_from'] if !opts[:'period_from'].nil?
      query_params[:'periodTo'] = opts[:'period_to'] if !opts[:'period_to'].nil?
      query_params[:'emailCampaignId[]'] = @api_client.build_collection_param(opts[:'email_campaign_id'], :multi) if !opts[:'email_campaign_id'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'EcommerceAttributionMetricsGet200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key']

      new_options = opts.merge(
        :operation => :"EcommerceApi.ecommerce_attribution_metrics_get",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: EcommerceApi#ecommerce_attribution_metrics_get\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get attributed product sales for a single Brevo campaign
    # @param conversion_source [String] The Brevo campaign type for which data will be retrieved
    # @param conversion_source_id [Float] The Brevo campaign id for which data will be retrieved
    # @param [Hash] opts the optional parameters
    # @return [EcommerceAttributionProductsConversionSourceConversionSourceIdGet200Response]
    def ecommerce_attribution_products_conversion_source_conversion_source_id_get(conversion_source, conversion_source_id, opts = {})
      data, _status_code, _headers = ecommerce_attribution_products_conversion_source_conversion_source_id_get_with_http_info(conversion_source, conversion_source_id, opts)
      data
    end

    # Get attributed product sales for a single Brevo campaign
    # @param conversion_source [String] The Brevo campaign type for which data will be retrieved
    # @param conversion_source_id [Float] The Brevo campaign id for which data will be retrieved
    # @param [Hash] opts the optional parameters
    # @return [Array<(EcommerceAttributionProductsConversionSourceConversionSourceIdGet200Response, Integer, Hash)>] EcommerceAttributionProductsConversionSourceConversionSourceIdGet200Response data, response status code and response headers
    def ecommerce_attribution_products_conversion_source_conversion_source_id_get_with_http_info(conversion_source, conversion_source_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: EcommerceApi.ecommerce_attribution_products_conversion_source_conversion_source_id_get ...'
      end
      # verify the required parameter 'conversion_source' is set
      if @api_client.config.client_side_validation && conversion_source.nil?
        fail ArgumentError, "Missing the required parameter 'conversion_source' when calling EcommerceApi.ecommerce_attribution_products_conversion_source_conversion_source_id_get"
      end
      # verify enum value
      allowable_values = ["email_campaign"]
      if @api_client.config.client_side_validation && !allowable_values.include?(conversion_source)
        fail ArgumentError, "invalid value for \"conversion_source\", must be one of #{allowable_values}"
      end
      # verify the required parameter 'conversion_source_id' is set
      if @api_client.config.client_side_validation && conversion_source_id.nil?
        fail ArgumentError, "Missing the required parameter 'conversion_source_id' when calling EcommerceApi.ecommerce_attribution_products_conversion_source_conversion_source_id_get"
      end
      # resource path
      local_var_path = '/ecommerce/attribution/products/{conversionSource}/{conversionSourceId}'.sub('{' + 'conversionSource' + '}', CGI.escape(conversion_source.to_s)).sub('{' + 'conversionSourceId' + '}', CGI.escape(conversion_source_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'EcommerceAttributionProductsConversionSourceConversionSourceIdGet200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key']

      new_options = opts.merge(
        :operation => :"EcommerceApi.ecommerce_attribution_products_conversion_source_conversion_source_id_get",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: EcommerceApi#ecommerce_attribution_products_conversion_source_conversion_source_id_get\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Return all your categories
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :limit Number of documents per page (default to 50)
    # @option opts [Integer] :offset Index of the first document in the page (default to 0)
    # @option opts [String] :sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed (default to 'desc')
    # @option opts [Array<String>] :ids Filter by category ids
    # @option opts [String] :name Filter by category name
    # @option opts [String] :modified_since Filter (urlencoded) the categories modified after a given UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). **Prefer to pass your timezone in date-time format for accurate result.** 
    # @option opts [String] :created_since Filter (urlencoded) the categories created after a given UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). **Prefer to pass your timezone in date-time format for accurate result.** 
    # @return [GetCategories]
    def get_categories(opts = {})
      data, _status_code, _headers = get_categories_with_http_info(opts)
      data
    end

    # Return all your categories
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :limit Number of documents per page (default to 50)
    # @option opts [Integer] :offset Index of the first document in the page (default to 0)
    # @option opts [String] :sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed (default to 'desc')
    # @option opts [Array<String>] :ids Filter by category ids
    # @option opts [String] :name Filter by category name
    # @option opts [String] :modified_since Filter (urlencoded) the categories modified after a given UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). **Prefer to pass your timezone in date-time format for accurate result.** 
    # @option opts [String] :created_since Filter (urlencoded) the categories created after a given UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). **Prefer to pass your timezone in date-time format for accurate result.** 
    # @return [Array<(GetCategories, Integer, Hash)>] GetCategories data, response status code and response headers
    def get_categories_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: EcommerceApi.get_categories ...'
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 100
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling EcommerceApi.get_categories, must be smaller than or equal to 100.'
      end

      allowable_values = ["asc", "desc"]
      if @api_client.config.client_side_validation && opts[:'sort'] && !allowable_values.include?(opts[:'sort'])
        fail ArgumentError, "invalid value for \"sort\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/categories'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'sort'] = opts[:'sort'] if !opts[:'sort'].nil?
      query_params[:'ids'] = @api_client.build_collection_param(opts[:'ids'], :multi) if !opts[:'ids'].nil?
      query_params[:'name'] = opts[:'name'] if !opts[:'name'].nil?
      query_params[:'modifiedSince'] = opts[:'modified_since'] if !opts[:'modified_since'].nil?
      query_params[:'createdSince'] = opts[:'created_since'] if !opts[:'created_since'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'GetCategories'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key']

      new_options = opts.merge(
        :operation => :"EcommerceApi.get_categories",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: EcommerceApi#get_categories\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a category details
    # @param id [String] Category ID
    # @param [Hash] opts the optional parameters
    # @return [GetCategoryDetails]
    def get_category_info(id, opts = {})
      data, _status_code, _headers = get_category_info_with_http_info(id, opts)
      data
    end

    # Get a category details
    # @param id [String] Category ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(GetCategoryDetails, Integer, Hash)>] GetCategoryDetails data, response status code and response headers
    def get_category_info_with_http_info(id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: EcommerceApi.get_category_info ...'
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling EcommerceApi.get_category_info"
      end
      # resource path
      local_var_path = '/categories/{id}'.sub('{' + 'id' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'GetCategoryDetails'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key']

      new_options = opts.merge(
        :operation => :"EcommerceApi.get_category_info",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: EcommerceApi#get_category_info\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get order details
    # Get all the orders
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :limit Number of documents per page (default to 50)
    # @option opts [Integer] :offset Index of the first document in the page (default to 0)
    # @option opts [String] :sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed (default to 'desc')
    # @option opts [String] :modified_since Filter (urlencoded) the orders modified after a given UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). **Prefer to pass your timezone in date-time format for accurate result.** 
    # @option opts [String] :created_since Filter (urlencoded) the orders created after a given UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). **Prefer to pass your timezone in date-time format for accurate result.** 
    # @return [nil]
    def get_orders(opts = {})
      get_orders_with_http_info(opts)
      nil
    end

    # Get order details
    # Get all the orders
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :limit Number of documents per page (default to 50)
    # @option opts [Integer] :offset Index of the first document in the page (default to 0)
    # @option opts [String] :sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed (default to 'desc')
    # @option opts [String] :modified_since Filter (urlencoded) the orders modified after a given UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). **Prefer to pass your timezone in date-time format for accurate result.** 
    # @option opts [String] :created_since Filter (urlencoded) the orders created after a given UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). **Prefer to pass your timezone in date-time format for accurate result.** 
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def get_orders_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: EcommerceApi.get_orders ...'
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 100
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling EcommerceApi.get_orders, must be smaller than or equal to 100.'
      end

      allowable_values = ["asc", "desc"]
      if @api_client.config.client_side_validation && opts[:'sort'] && !allowable_values.include?(opts[:'sort'])
        fail ArgumentError, "invalid value for \"sort\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/orders'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'sort'] = opts[:'sort'] if !opts[:'sort'].nil?
      query_params[:'modifiedSince'] = opts[:'modified_since'] if !opts[:'modified_since'].nil?
      query_params[:'createdSince'] = opts[:'created_since'] if !opts[:'created_since'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key']

      new_options = opts.merge(
        :operation => :"EcommerceApi.get_orders",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: EcommerceApi#get_orders\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a product's details
    # @param id [String] Product ID
    # @param [Hash] opts the optional parameters
    # @return [GetProductDetails]
    def get_product_info(id, opts = {})
      data, _status_code, _headers = get_product_info_with_http_info(id, opts)
      data
    end

    # Get a product&#39;s details
    # @param id [String] Product ID
    # @param [Hash] opts the optional parameters
    # @return [Array<(GetProductDetails, Integer, Hash)>] GetProductDetails data, response status code and response headers
    def get_product_info_with_http_info(id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: EcommerceApi.get_product_info ...'
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling EcommerceApi.get_product_info"
      end
      # resource path
      local_var_path = '/products/{id}'.sub('{' + 'id' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'GetProductDetails'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key']

      new_options = opts.merge(
        :operation => :"EcommerceApi.get_product_info",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: EcommerceApi#get_product_info\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Return all your products
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :limit Number of documents per page (default to 50)
    # @option opts [Integer] :offset Index of the first document in the page (default to 0)
    # @option opts [String] :sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed (default to 'desc')
    # @option opts [Array<String>] :ids Filter by product ids
    # @option opts [String] :name Filter by product name, minimum 3 characters should be present for search
    # @option opts [Float] :price_lte Price filter for products less than and equals to particular amount
    # @option opts [Float] :price_gte Price filter for products greater than and equals to particular amount
    # @option opts [Float] :price_lt Price filter for products less than particular amount
    # @option opts [Float] :price_gt Price filter for products greater than particular amount
    # @option opts [Float] :price_eq Price filter for products equals to particular amount
    # @option opts [Float] :price_ne Price filter for products not equals to particular amount
    # @option opts [Array<String>] :categories Filter by product categories
    # @option opts [String] :modified_since Filter (urlencoded) the orders modified after a given UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). **Prefer to pass your timezone in date-time format for accurate result.** 
    # @option opts [String] :created_since Filter (urlencoded) the orders created after a given UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). **Prefer to pass your timezone in date-time format for accurate result.** 
    # @return [GetProducts]
    def get_products(opts = {})
      data, _status_code, _headers = get_products_with_http_info(opts)
      data
    end

    # Return all your products
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :limit Number of documents per page (default to 50)
    # @option opts [Integer] :offset Index of the first document in the page (default to 0)
    # @option opts [String] :sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed (default to 'desc')
    # @option opts [Array<String>] :ids Filter by product ids
    # @option opts [String] :name Filter by product name, minimum 3 characters should be present for search
    # @option opts [Float] :price_lte Price filter for products less than and equals to particular amount
    # @option opts [Float] :price_gte Price filter for products greater than and equals to particular amount
    # @option opts [Float] :price_lt Price filter for products less than particular amount
    # @option opts [Float] :price_gt Price filter for products greater than particular amount
    # @option opts [Float] :price_eq Price filter for products equals to particular amount
    # @option opts [Float] :price_ne Price filter for products not equals to particular amount
    # @option opts [Array<String>] :categories Filter by product categories
    # @option opts [String] :modified_since Filter (urlencoded) the orders modified after a given UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). **Prefer to pass your timezone in date-time format for accurate result.** 
    # @option opts [String] :created_since Filter (urlencoded) the orders created after a given UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). **Prefer to pass your timezone in date-time format for accurate result.** 
    # @return [Array<(GetProducts, Integer, Hash)>] GetProducts data, response status code and response headers
    def get_products_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: EcommerceApi.get_products ...'
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling EcommerceApi.get_products, must be smaller than or equal to 1000.'
      end

      allowable_values = ["asc", "desc"]
      if @api_client.config.client_side_validation && opts[:'sort'] && !allowable_values.include?(opts[:'sort'])
        fail ArgumentError, "invalid value for \"sort\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/products'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'sort'] = opts[:'sort'] if !opts[:'sort'].nil?
      query_params[:'ids'] = @api_client.build_collection_param(opts[:'ids'], :multi) if !opts[:'ids'].nil?
      query_params[:'name'] = opts[:'name'] if !opts[:'name'].nil?
      query_params[:'price[lte]'] = opts[:'price_lte'] if !opts[:'price_lte'].nil?
      query_params[:'price[gte]'] = opts[:'price_gte'] if !opts[:'price_gte'].nil?
      query_params[:'price[lt]'] = opts[:'price_lt'] if !opts[:'price_lt'].nil?
      query_params[:'price[gt]'] = opts[:'price_gt'] if !opts[:'price_gt'].nil?
      query_params[:'price[eq]'] = opts[:'price_eq'] if !opts[:'price_eq'].nil?
      query_params[:'price[ne]'] = opts[:'price_ne'] if !opts[:'price_ne'].nil?
      query_params[:'categories'] = @api_client.build_collection_param(opts[:'categories'], :multi) if !opts[:'categories'].nil?
      query_params[:'modifiedSince'] = opts[:'modified_since'] if !opts[:'modified_since'].nil?
      query_params[:'createdSince'] = opts[:'created_since'] if !opts[:'created_since'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'GetProducts'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api-key']

      new_options = opts.merge(
        :operation => :"EcommerceApi.get_products",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: EcommerceApi#get_products\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
